## web请求过程

### 发起一个http请求的过程就是建立一个socket通信的过程，只不过outputStreamWriter写的二进制字节数据格式要符合HTTP要求

### http Header控制着用户浏览器的渲染行为和服务器的执行逻辑
  - 常见的http请求头
    - Accept-Charset: 用于指定客户端接收的字符集
    - Accept-Encoding: 可接受的内容编码
    - Accept-Language: 指定一种自然语言
    - Host: 被请求资源的主机和端口
    - User-Agent: 客户端自己的操作系统，浏览器和其他属性
    - Connection: 当前连接是否保持
  - 常见的http响应头
    - server: 服务器名
    - Content-Type: 响应实体正文的媒体类型
    - Content-Encoding: 与Accept-Encoding对应
    - Content-Language: 与Accept-Language对应
    - Content-Length: 实体正文的长度（以字节方式存储的10进制数的长度）
    - Keep-Alive: 保持连接的时间
  - 常见的http状态码
    - 200: 请求成功
    - 302: 临时跳转，location指定
    - 400: 请求有语法错误，服务器不能识别
    - 403: 服务器收到请求，但是拒绝提供服务
    - 404: 请求的资源不存在
    - 500: 服务器发生不可预测的错误

### 通常使用Cache-Control来进行缓存设置
  - Public: 响应头设置，所有内容都会被缓存
  - Private: 响应头设置，内容只缓存到私有缓存中
  - no-cache: 双边设置，所有内容都不会被缓存
  - no-store: 响应头设置，所有内容都不会被缓存到缓存或internet临时文件中
  - must-revalidation/proxy-revalidation: 请求头设置，如果缓存的内容失效，请求必须发送到服务器/代理服务器以进行重新验证
  - max-age=xxx: 响应头中设置，缓存的内容将在xxx秒后失效

### 我们通过DNS服务来进行域名的解析
  1. 检查浏览器缓存（缓存时间通过TTL属性来设置）
  2. 检查操作系统缓存（就是host文件）
  3. 发送请求给本地DNS服务器请求域名解析（ipconfig里，这个服务器也就是通常所说的SPA）
  4. 访问gTLD，获得对应关系返回给本地DNS服务器

### JVM也会缓存DNS解析结果，会以成功解析和失败解析两种状态记录缓存，通过InetAddress类来完成

### 域名解析记录
  - A记录：用来指定域名对应的IP地址
  - MX记录：用来指定邮件转发服务
  - CNAME记录：别名解析，为一个域名设置一个或多个别名
  - NS记录：用来指定域名对应的指定DNS服务器IP
  - TXT记录：为某个主机或域名设置说明

### CDN内容分布网络，主要以缓存网络中的静态资源为主，通过镜像技术、缓存、整体负载均衡技术提高用户访问网站的响应速度

### 负载均衡技术
  - 链路负载均衡：通过DNS解析成不同的IP，然后根据这个IP来访问不同的服务器（CDN服务）
    - 优点：直接访问目标服务器，不需要代理
    - 缺点：难以及时更新用户的域名解析结构
  - 集群负载均衡（web服务，分布式服务主要内容）
    - 硬件负载均衡：使用硬件设备来转发请求（如F5）
      - 优点：性能棒
      - 缺点：死贵
    - 软件负载均衡：通过将请求进行多次转发最终到达服务器来进行
      - 优点：便宜
      - 缺点：网络延时会有所增加
  - 操作系统负载均衡：通过操作系统级别的软中断或者硬件中断来达到负载均衡的目的，如多队列网卡。

### CDN动态加速，在dns解析中通过动态的链路探测找到CDN中回源最好的一条链路 

## java/IO

### 基本的I/O操作接口
  - 基于字节操作的接口：InputStream/OutputStream
  - 基于字符操作的接口：Reader/Writer
  - 基于磁盘操作的接口：File
  - 基于网络操作的接口：Socket

### 字符操作接口需要有字节和字符的转换接口，InputStreamReader、OutputStreamWriter就是相应的字节到字符（字符到字节）转换桥梁，在转换的过程中需要指定编码字符集，编/解码过程由StreamEncoder/StreamDecoder来执行

### 操作系统为了加速磁盘I/O访问速度会在内核空间使用缓存技术
  - 标准访问文件方式：read()的时候如果缓存了则从缓存读取，如果没缓存则访问物理磁盘，将内容缓存在操作系统中，write()的时候将内容吸入内核缓存后就结束，什么时候写入磁盘由操作系统判定或者显示的调用sync()命令
  - 直接访问磁盘：不经过内核缓存区，缓存控制由应用程序自己实现，典型应用就是数据库管理系统，缺点是数据的直接加载非常缓慢需要有很好的缓存管理策略
  - 同步访问：跟标准访问差不多，唯一的区别是写操作的时候必须要写入磁盘完成以后才给应用程序返回成功消息，这种访问方式性能较差，但是安全性很好，一般在数据安全要求比较高的场景使用，而且这种访问方式所使用的硬件一般也是定制的
  - 异步访问：发出操作请求的线程在消息发出后就去搞其他事，当请求的数据返回后继续处理下面的操作，这种访问方式可以显著提高应用程序的效率，但不会改变访问文件的效率
  - 内存映射：将内存中的一块区域与磁盘关联，因为这两个区域数据共享，所以访问内核的时候可以映射到磁盘上，这种操作的目的也是减少了数据从内核空间复制到用户空间的操作

### java中的File通常不代表一个真实存在的文件，而是一个代表这个文件的虚拟对象，它更关心的是对这个对象如何操作而不是这个对象是否存在
  1. 当传入一个File路径时，会创建一个File对象来标识这个文件
  2. 根据这个对象创建真正读取文件的操作对象（FileInputStream）
  3. 这时候会创建个真正关联磁盘文件的FileDescriptor，通过这个控制真实的文件，由于我们读取的字符格式所以会用到StreamDecoder类将byte解码为char格式

### java反序列化时必须有原始类作为模板才能将这个对象还原，这是因为序列化的数据并不像class文件一样保存类的完整信息，在多语言环境下尽量使用xml/json之类的结构数据：
  - 当父类继承Serializable时，所有子类都可以被序列化
  - 子类实现了Serializable接口，父类没有，父类中的属性不能被序列化，但是在子类中，属性仍能正确序列化
  - 如果序列化的属性是对象，则这个对象也必须实现Serializable接口
  - 反序列化时如果对象的属性有修改或删减，则修改的部分属性会丢失

### TCP

### 建立通信链路
  - 客户端：创建socket实例，操作系统分配端口号，创建一个包含本地地址，远程地址和端口号的套接字数据结构，发起tcp请求，进行三次握手，实例创建完成
  - 服务端：创建socketServer实例，设置监听地址，通常是*通配所有地址，阻塞状态等待客户端请求

### 每个socket实例都有一个inputStream对象和outputStream对象，数据通过这两个对象来交换

### NIO最大的特点是我们可以通过控制buffer来具体的调整内核地址空间与用户空间的数据交换详情（是否需要扩容，扩容多大，怎么扩容等）

### 在常见的web服务器中（tomcat、jetty）通常会有两个线程用来进行请求的监听跟请求的处理，监听请求的使用的是阻塞方式，请求处理使用的是非阻塞（NIO）方式
  - server端通过Selector来监听一组（一堆）通信信道（channel），每个通信信道对应一个buffer，通过监听channel的改变来将数据写到对应的buffer中，这种方式的特点是有一个线程来处理所有的连接的数据交互，每个连接的数据交互都不是阻塞的

### Buffer中通过4个索引变量来保存数据的位置状态
  - capacity 缓冲取数组的总长度
  - position 下一个要操作的数据元素的位置
  - limit 缓冲区数组中下一个不可操作的元素的位置
  - mark 用于记录当前position的前一个位置，默认0 

### 一般情况下channel中的数据要先经过操作系统缓冲区再到buffer中，我们可以通过directByteBuffer对象直接操作非JVM内存里的数据
  - heapByteBuffer I/O开销大，但是创建和回收开销小，适合并发连接数少于1000， I/O操作较少时使用
  - directByteBuffer I/O开销小，但是创建和回收开销大，适合数据量较大，生命周期较长时使用

### NIO操作磁盘数据时可以不经过jvm内存空间直接在内核空间里移动

### I/O优化
  - 磁盘I/O优化：增加缓存，优化磁盘管理系统（底层操作系统考虑），设置合适的数据块及访问策略（索引，异步，非阻塞），组raid
  - tcp优化：增加端口数量，减少等待时间，连接复用等
  - 网络I/O优化：减少网络交互次数，减少传输数据量的大小（压缩，设置代理），减少编码（尽量直接以字节方式进行发送）
    - 同步阻塞：
    - 同步非阻塞：
    - 异步阻塞：
    - 异步非阻塞：

### 适配器模式，将源接口适配成目标接口，继承源接口，实现目标接口（InputStreamReader, outputStreamWriter等）

### 装饰器模式，赋予被装饰类更多的功能的同时不改变原来类的使用（FilterInputStream,LineNumberInputStream等，这些都提升了InputStream的性能但为破坏原有类的使用方式）

### 装饰器与适配器模式都是包装模式，不同点：
  - 装饰器模式：增强类的功能的同时不改变其使用方式
  - 适配器模式：通过改变接口达到重复使用的目的

## javac编译原理

### 编译器完成编译过程的主要步骤
  1. 词法分析：找出哪些是我们定义的关键字，获得规范化的token流
  2. 语法分析：对这些token流进行语法分析，看是否符合语言规范，获得java语法树
  3. 语义分析：将复杂的语法转换成简单的语法，如foreach转换为for循环，注解等，获得注解语法树
  4. 代码生成：通过字节码生成器生成字节码

