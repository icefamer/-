## web请求过程

### 发起一个http请求的过程就是建立一个socket通信的过程，只不过outputStreamWriter写的二进制字节数据格式要符合HTTP要求

### http Header控制着用户浏览器的渲染行为和服务器的执行逻辑
  - 常见的http请求头
    - Accept-Charset: 用于指定客户端接收的字符集
    - Accept-Encoding: 可接受的内容编码
    - Accept-Language: 指定一种自然语言
    - Host: 被请求资源的主机和端口
    - User-Agent: 客户端自己的操作系统，浏览器和其他属性
    - Connection: 当前连接是否保持
  - 常见的http响应头
    - server: 服务器名
    - Content-Type: 响应实体正文的媒体类型
    - Content-Encoding: 与Accept-Encoding对应
    - Content-Language: 与Accept-Language对应
    - Content-Length: 实体正文的长度（以字节方式存储的10进制数的长度）
    - Keep-Alive: 保持连接的时间
  - 常见的http状态码
    - 200: 请求成功
    - 302: 临时跳转，location指定
    - 400: 请求有语法错误，服务器不能识别
    - 403: 服务器收到请求，但是拒绝提供服务
    - 404: 请求的资源不存在
    - 500: 服务器发生不可预测的错误

### 通常使用Cache-Control来进行缓存设置
  - Public: 响应头设置，所有内容都会被缓存
  - Private: 响应头设置，内容只缓存到私有缓存中
  - no-cache: 双边设置，所有内容都不会被缓存
  - no-store: 响应头设置，所有内容都不会被缓存到缓存或internet临时文件中
  - must-revalidation/proxy-revalidation: 请求头设置，如果缓存的内容失效，请求必须发送到服务器/代理服务器以进行重新验证
  - max-age=xxx: 响应头中设置，缓存的内容将在xxx秒后失效

### 我们通过DNS服务来进行域名的解析
  1. 检查浏览器缓存（缓存时间通过TTL属性来设置）
  2. 检查操作系统缓存（就是host文件）
  3. 发送请求给本地DNS服务器请求域名解析（ipconfig里，这个服务器也就是通常所说的SPA）
  4. 访问gTLD，获得对应关系返回给本地DNS服务器

### JVM也会缓存DNS解析结果，会以成功解析和失败解析两种状态记录缓存，通过InetAddress类来完成

### 域名解析记录
  - A记录：用来指定域名对应的IP地址
  - MX记录：用来指定邮件转发服务
  - CNAME记录：别名解析，为一个域名设置一个或多个别名
  - NS记录：用来指定域名对应的指定DNS服务器IP
  - TXT记录：为某个主机或域名设置说明

### CDN内容分布网络，主要以缓存网络中的静态资源为主，通过镜像技术、缓存、整体负载均衡技术提高用户访问网站的响应速度

### 负载均衡技术
  - 链路负载均衡：通过DNS解析成不同的IP，然后根据这个IP来访问不同的服务器（CDN服务）
    - 优点：直接访问目标服务器，不需要代理
    - 缺点：难以及时更新用户的域名解析结构
  - 集群负载均衡（web服务，分布式服务主要内容）
    - 硬件负载均衡：使用硬件设备来转发请求（如F5）
      - 优点：性能棒
      - 缺点：死贵
    - 软件负载均衡：通过将请求进行多次转发最终到达服务器来进行
      - 优点：便宜
      - 缺点：网络延时会有所增加
  - 操作系统负载均衡：通过操作系统级别的软中断或者硬件中断来达到负载均衡的目的，如多队列网卡。

### CDN动态加速，在dns解析中通过动态的链路探测找到CDN中回源最好的一条链路 
<<<<<<< HEAD

## java/IO

### 基本的I/O操作接口
  - 基于字节操作的接口：InputStream/OutputStream
  - 基于字符操作的接口：Reader/Writer
  - 基于磁盘操作的接口：File
  - 基于网络操作的接口：Socket

### 字符操作接口需要有字节和字符的转换接口，InputStreamReader、OutputStreamWriter就是相应的字节到字符（字符到字节）转换桥梁，在转换的过程中需要指定编码字符集，编/解码过程由StreamEncoder/StreamDecoder来执行

### 操作系统为了加速磁盘I/O访问速度会在内核空间使用缓存技术
  - 标准访问文件方式：read()的时候如果缓存了则从缓存读取，如果没缓存则访问物理磁盘，将内容缓存在操作系统中，write()的时候将内容吸入内核缓存后就结束，什么时候写入磁盘由操作系统判定或者显示的调用sync()命令
  - 直接访问磁盘：不经过内核缓存区，缓存控制由应用程序自己实现，典型应用就是数据库管理系统，缺点是数据的直接加载非常缓慢需要有很好的缓存管理策略
  - 同步访问：跟标准访问差不多，唯一的区别是写操作的时候必须要写入磁盘完成以后才给应用程序返回成功消息，这种访问方式性能较差，但是安全性很好，一般在数据安全要求比较高的场景使用，而且这种访问方式所使用的硬件一般也是定制的
  - 异步访问：发出操作请求的线程在消息发出后就去搞其他事，当请求的数据返回后继续处理下面的操作，这种访问方式可以显著提高应用程序的效率，但不会改变访问文件的效率
  - 内存映射：将内存中的一块区域与磁盘关联，因为这两个区域数据共享，所以访问内核的时候可以映射到磁盘上，这种操作的目的也是减少了数据从内核空间复制到用户空间的操作

### java中的File通常不代表一个真实存在的文件，而是一个代表这个文件的虚拟对象，它更关心的是对这个对象如何操作而不是这个对象是否存在
  1. 当传入一个File路径时，会创建一个File对象来标识这个文件
  2. 根据这个对象创建真正读取文件的操作对象（FileInputStream）
  3. 这时候会创建个真正关联磁盘文件的FileDescriptor，通过这个控制真实的文件，由于我们读取的字符格式所以会用到StreamDecoder类将byte解码为char格式

### java反序列化时必须有原始类作为模板才能将这个对象还原，这是因为序列化的数据并不像class文件一样保存类的完整信息，在多语言环境下尽量使用xml/json之类的结构数据：
  - 当父类继承Serializable时，所有子类都可以被序列化
  - 子类实现了Serializable接口，父类没有，父类中的属性不能被序列化，但是在子类中，属性仍能正确序列化
  - 如果序列化的属性是对象，则这个对象也必须实现Serializable接口
  - 反序列化时如果对象的属性有修改或删减，则修改的部分属性会丢失

### TCP

### 建立通信链路
  - 客户端：
=======
>>>>>>> c014585f1c6e69d14449af0b86312c9655a36979
