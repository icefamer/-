1. 多线程
    1. 线程常用状态操作方法：
        1. sleep: Thread类的静态方法，让线程休眠指定时间
        2. wait: Object的方法，调用此方法会将调用者的线程挂起，使该线程进入waitSet的等待区域，直到其他线程调用同一个对象的notify方法，这个对象才会被重新激活，跟sleep的区别在于调用wait方法后它会释放自己占用的锁标记，从而让其他线程能够使用对象中的synchronize数据。
        3. yeild：表示停止当前线程，使该线程进入可执行状态，让同等优先级的线程运行，如果没有同等优先级的线程，那么yeild方法不会起作用
        4. notify、notifyAll：唤醒wait状态的线程，一个或所有
    2. 线程池的原理，为什么要创建线程池，创建线程池的方式？
        当需要多个线程执行非复杂任务的时候我们可以采用线程池以提高服务器性能，我们可以通过使用Executors提供的几个方法来创建线程池，推荐使用new CacheThreadExecutor()来创建可缓存线程池，当线程池大小超过了处理任务所需的线程，那么就会回收部分空闲（一般是60秒无执行）的线程，当有任务来时，又智能的添加新线程来执行
    3. 线程的生命周期
        1. 新建：当程序使用new关键字后，jvm为其分配内存并初始成员变量
        2. 就绪：当线程调用了start方法后，进入就绪状态，jvm会为其创建方法调用栈和程序计数器，等待调度运行
        3. 运行：就绪状态的线程获得cpu开始执行run方法
        4. 阻塞：当处于运行状态的线程失去所占用资源之后
        5. 死亡：线程销毁释放内存
    4. 线程安全
        只有存在共享数据时才需要考虑线程安全问题，常用的解决线程安全性的方法是同步，使用synchronized和lock都可以。
    5. volatile, synchronized, ThreadLocal
        1. volatile的主要作用是确保可视性，既保证在任何时刻，多个不同的线程总是看到某个成员变量的同一个值。
        2. synchronized用来给线程加锁（还可以通过实现concurrent包中的lock接口实现），如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁则其他线程便只能等待，直到此线程释放锁。
        3. 死锁指的是两个或两个以上的线程在执行过程中，因竞争资源而造成的一种互相等待的现象。死锁产生不需同时满足以下四个条件：
            1. 互斥：要求对所分配的资源进行排他性控制（synchronized）
            2. 不剥夺：不能强行剥夺被获取的资源
            3. 请求保持：已经获得至少一个资源的同时又提出新的资源请求，但新的资源也被其他线程占有
            4. 循环等待：等待资源的线程组成了一个循环等待的闭环
2. 集合框架
3. 设计模式
    1. 单例模式
        1. 懒汉式：在调用工厂方法前都没有实例创建，种方式需要注意线程安全问题
        2. 饿汉式：通过static在编译阶段就创建好实例，这种方式天然线程安全
    2. 工厂模式
        1. 在编码阶段不能预见需要创建哪种类的实例
        2. 系统不应依赖于产品类实例如何被创建，组合和表达的细节
    3. 
4. JVM相关